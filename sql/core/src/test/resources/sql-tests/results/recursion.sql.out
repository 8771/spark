-- Automatically generated by SQLQueryTestSuite
-- Number of queries: 25


-- !query 0
WITH r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 0 schema
struct<>
-- !query 0 output
org.apache.spark.sql.AnalysisException
Table or view not found: r; line 4 pos 30


-- !query 1
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r ORDER BY level
-- !query 1 schema
struct<level:int,data:string>
-- !query 1 output
0	A
1	A
2	A
3	A
4	A
5	A
6	A
7	A
8	A
9	A
10	A


-- !query 2
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r
)
SELECT * FROM r ORDER BY level
-- !query 2 schema
struct<>
-- !query 2 output
org.apache.spark.SparkException
Recursion level limit reached but query hasn't exhausted, try increasing spark.sql.recursion.level.limit


-- !query 3
WITH RECURSIVE r AS (
  SELECT level + 1, data FROM r WHERE level < 10
  UNION ALL
  VALUES (0, 'A') AS T(level, data)
)
SELECT * FROM r ORDER BY level
-- !query 3 schema
struct<level:int,data:string>
-- !query 3 output
0	A
1	A
2	A
3	A
4	A
5	A
6	A
7	A
8	A
9	A
10	A


-- !query 4
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
  UNION ALL
  VALUES (0, 'B') AS T(level, data)
)
SELECT * FROM r ORDER BY level
-- !query 4 schema
struct<level:int,data:string>
-- !query 4 output
0	A
0	B
1	A
1	B
2	A
2	B
3	A
3	B


-- !query 5
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
)
SELECT * FROM r ORDER BY level
-- !query 5 schema
struct<level:int,data:string>
-- !query 5 output
0	A
1	A
1	A
2	A
2	A
2	A
2	A
3	A
3	A
3	A
3	A
3	A
3	A
3	A
3	A


-- !query 6
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  VALUES (0, 'B') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
)
SELECT * FROM r ORDER BY level
-- !query 6 schema
struct<level:int,data:string>
-- !query 6 output
0	A
0	B
1	A
1	B
1	A
1	B
2	A
2	B
2	A
2	B
2	A
2	B
2	A
2	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B


-- !query 7
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  INTERSECT
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 7 schema
struct<>
-- !query 7 output
org.apache.spark.sql.AnalysisException
Wrong usage of recursive reference r;


-- !query 8
WITH RECURSIVE r AS (
  SELECT level + 1, data FROM r WHERE level < 3
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
)
SELECT * FROM r
-- !query 8 schema
struct<>
-- !query 8 output
org.apache.spark.sql.AnalysisException
There should be at least 1 anchor term defined in a recursive query `r`;


-- !query 9
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE (SELECT SUM(level) FROM r) < 10
)
SELECT * FROM r
-- !query 9 schema
struct<>
-- !query 9 output
org.apache.spark.sql.AnalysisException
Recursive reference r can't be used in a subquery;


-- !query 10
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, r1.data
  FROM r AS r1
  JOIN r AS r2 ON r2.data = r1.data
)
SELECT * FROM r
-- !query 10 schema
struct<>
-- !query 10 output
org.apache.spark.sql.AnalysisException
Recursive reference can't be used in on both side of an inner join;


-- !query 11
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, r.data
  FROM (SELECT 'B' AS data) AS o
  LEFT JOIN r ON r.data = o.data
)
SELECT * FROM r
-- !query 11 schema
struct<>
-- !query 11 output
org.apache.spark.sql.AnalysisException
Recursive reference r can't be used at the right side of a left outer join;


-- !query 12
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  RIGHT JOIN (SELECT 'B' AS data) AS o ON o.data = r.data
)
SELECT * FROM r
-- !query 12 schema
struct<>
-- !query 12 output
org.apache.spark.sql.AnalysisException
Recursive reference r can't be used at the left side of a right outer join;


-- !query 13
WITH RECURSIVE r AS (
  SELECT MAX(level) AS level, SUM(data) AS data FROM VALUES (0, 1), (0, 2) AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r ORDER BY level
-- !query 13 schema
struct<level:int,data:bigint>
-- !query 13 output
0	3
1	3
2	3
3	3
4	3
5	3
6	3
7	3
8	3
9	3
10	3


-- !query 14
WITH RECURSIVE r AS (
  VALUES (0, 1L) AS T(group, data)
  UNION ALL
  SELECT 1, SUM(data) FROM r WHERE data < 10 GROUP BY group
)
SELECT * FROM r
-- !query 14 schema
struct<>
-- !query 14 output
org.apache.spark.sql.AnalysisException
Recursive reference r can't be used in an aggregate;


-- !query 15
WITH RECURSIVE r AS (
  VALUES (1L) AS T(data)
  UNION ALL
  SELECT SUM(data) FROM r WHERE data < 10
)
SELECT * FROM r
-- !query 15 schema
struct<>
-- !query 15 output
org.apache.spark.sql.AnalysisException
Recursive reference r can't be used in an aggregate;


-- !query 16
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT COUNT(*) FROM r
-- !query 16 schema
struct<count(1):bigint>
-- !query 16 output
11


-- !query 17
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT DISTINCT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 17 schema
struct<>
-- !query 17 output
org.apache.spark.sql.AnalysisException
Recursive reference r can't be used with distinct;


-- !query 18
CREATE TEMPORARY VIEW department AS SELECT * FROM VALUES
  (0, null, "ROOT"),
  (1, 0, "A"),
  (2, 1, "B"),
  (3, 2, "C"),
  (4, 2, "D"),
  (5, 0, "E"),
  (6, 4, "F"),
  (7, 5, "G")
  AS department(id, parent_department_id, name)
-- !query 18 schema
struct<>
-- !query 18 output



-- !query 19
WITH RECURSIVE subdepartment AS (
  SELECT * FROM department WHERE name = 'A'
  UNION ALL
  SELECT d.*
  FROM department AS d
  JOIN subdepartment AS sd ON (sd.id = d.parent_department_id)
)
SELECT id, name FROM subdepartment ORDER BY name
-- !query 19 schema
struct<id:int,name:string>
-- !query 19 output
1	A
2	B
3	C
4	D
6	F


-- !query 20
WITH RECURSIVE subdepartment AS (
  SELECT * FROM department WHERE name = 'A'
  UNION ALL
  SELECT d.*
  FROM department AS d
  JOIN subdepartment AS sd ON (sd.parent_department_id = d.id)
)
SELECT id, name FROM subdepartment ORDER BY name
-- !query 20 schema
struct<id:int,name:string>
-- !query 20 output
1	A
0	ROOT


-- !query 21
CREATE TEMPORARY VIEW routes AS SELECT * FROM VALUES
  ('New York', 'Washington'),
  ('New York', 'Boston'),
  ('Boston', 'New York'),
  ('Washington', 'Boston'),
  ('Washington', 'Raleigh')
  AS routes(origin, destination)
-- !query 21 schema
struct<>
-- !query 21 output



-- !query 22
WITH RECURSIVE destinations_from_new_york AS (
  SELECT 'New York' AS destination, ARRAY('New York') AS path, 0 AS length
  UNION ALL
  SELECT r.destination, CONCAT(d.path, ARRAY(r.destination)), d.length + 1
  FROM routes AS r
  JOIN destinations_from_new_york AS d ON d.destination = r.origin AND NOT ARRAY_CONTAINS(d.path, r.destination)
)
SELECT * FROM destinations_from_new_york
-- !query 22 schema
struct<destination:string,path:array<string>,length:int>
-- !query 22 output
Boston	["New York","Boston"]	1
Boston	["New York","Washington","Boston"]	2
New York	["New York"]	0
Raleigh	["New York","Washington","Raleigh"]	2
Washington	["New York","Washington"]	1


-- !query 23
WITH RECURSIVE fibonacci AS (
  VALUES (0, 1) AS T(a, b)
  UNION ALL
  SELECT b, a + b FROM fibonacci WHERE a < 10
)
SELECT a FROM fibonacci ORDER BY a
-- !query 23 schema
struct<a:int>
-- !query 23 output
0
1
1
2
3
5
8
13


-- !query 24
WITH RECURSIVE sudoku AS (
  VALUES (
    ARRAY(
      0, 0, 6, 0, 2, 3, 0, 0, 1,
      5, 0, 0, 0, 0, 0, 9, 0, 0,
      0, 0, 2, 0, 0, 4, 0, 0, 0,
      2, 0, 0, 8, 0, 0, 0, 9, 3,
      0, 0, 1, 0, 0, 7, 0, 0, 0,
      8, 3, 0, 0, 0, 0, 4, 0, 0,
      6, 0, 0, 1, 0, 0, 5, 0, 4,
      0, 5, 0, 0, 0, 0, 6, 0, 0,
      0, 0, 9, 0, 7, 0, 0, 2, 0
    ),
    0
  ) AS T(puzzle, level)
  UNION ALL
  SELECT
    CONCAT(SLICE(puzzle, 1, newPosition - 1), ARRAY(newValue), SLICE(puzzle, newPosition + 1, 9 * 9 - newPosition)),
    level + 1
  FROM (
    SELECT
      puzzle,
      newPosition,
      EXPLODE(allowedValues) AS newValue,
      level
    FROM (
      SELECT
        puzzle,
        newPosition,
        ARRAY_EXCEPT(
          ARRAY_EXCEPT(
            ARRAY_EXCEPT(
              SEQUENCE(1, 9),
              -- used values in row
              SLICE(puzzle, FLOOR((newPosition - 1) / 9) * 9 + 1, 9)
            ),
            -- used values in column
            TRANSFORM(puzzle, (x, i) -> IF(i % 9 = (newPosition - 1) % 9, x, 0))
          ),
          -- used values in 3x3 block
          TRANSFORM(
            SLICE(puzzle, FLOOR((newPosition - 1) / (3 * 9)) * 3 * 9 + 1, 3 * 9),
            (x, i) -> IF(FLOOR(i / 3) % 3 = FLOOR((newPosition - 1) / 3) % 3, x, 0)
          )
        ) AS allowedValues,
        level
      FROM sudoku
      JOIN (SELECT EXPLODE(SEQUENCE(1, 9 * 9)) AS newPosition) ON puzzle[newPosition - 1] = 0
      ORDER BY SIZE(allowedValues)
      LIMIT 1
    )
  )
)
SELECT * FROM sudoku WHERE NOT ARRAY_CONTAINS(puzzle, 0)
-- !query 24 schema
struct<puzzle:array<int>,level:int>
-- !query 24 output
[4,8,6,9,2,3,7,5,1,5,1,3,7,6,8,9,4,2,7,9,2,5,1,4,8,3,6,2,7,4,8,5,6,1,9,3,9,6,1,3,4,7,2,8,5,8,3,5,2,9,1,4,6,7,6,2,8,1,3,9,5,7,4,3,5,7,4,8,2,6,1,9,1,4,9,6,7,5,3,2,8]	55

-- Automatically generated by SQLQueryTestSuite
-- Number of queries: 74


-- !query 0
WITH r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 0 schema
struct<>
-- !query 0 output
org.apache.spark.sql.AnalysisException
Table or view not found: r; line 4 pos 30


-- !query 1
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r ORDER BY level
-- !query 1 schema
struct<level:int,data:string>
-- !query 1 output
0	A
1	A
2	A
3	A
4	A
5	A
6	A
7	A
8	A
9	A
10	A


-- !query 2
WITH RECURSIVE t AS (
  VALUES (1) AS T(n)
  UNION ALL
  SELECT n + 1 FROM t WHERE n < 100
)
SELECT SUM(n) FROM t
-- !query 2 schema
struct<sum(n):bigint>
-- !query 2 output
5050


-- !query 3
WITH RECURSIVE t AS (
  SELECT (VALUES(1)) AS n
  UNION ALL
  SELECT n + 1 FROM t WHERE n < 5
)
SELECT * FROM t
-- !query 3 schema
struct<n:int>
-- !query 3 output
1
2
3
4
5


-- !query 4
WITH RECURSIVE t AS (
  VALUES (1) AS T(n)
  UNION ALL
  SELECT n + 1 FROM t
)
SELECT * FROM t LIMIT 10
-- !query 4 schema
struct<n:int>
-- !query 4 output
1
10
2
3
4
5
6
7
8
9


-- !query 5
WITH RECURSIVE t AS (
  SELECT 'foo' AS n
  UNION ALL
  SELECT n || ' bar' FROM t WHERE LENGTH(n) < 20
)
SELECT n FROM t
-- !query 5 schema
struct<n:string>
-- !query 5 output
foo
foo bar
foo bar bar
foo bar bar bar
foo bar bar bar bar
foo bar bar bar bar bar


-- !query 6
CREATE TEMPORARY VIEW sums_1_100 AS
WITH RECURSIVE t AS (
  VALUES (1) AS T(n)
  UNION ALL
  SELECT n + 1 FROM t WHERE n < 100
)
SELECT SUM(n) FROM t
-- !query 6 schema
struct<>
-- !query 6 output



-- !query 7
SELECT * FROM sums_1_100
-- !query 7 schema
struct<sum(n):bigint>
-- !query 7 output
5050


-- !query 8
WITH RECURSIVE t AS (
  VALUES (1, 2) AS T(i, j)
  UNION ALL
  SELECT t2.i, t.j + 1
  FROM (
    SELECT 2 AS i
    UNION ALL SELECT 3 AS i
  ) AS t2
  JOIN t ON (t2.i = t.i + 1)
)
SELECT * FROM t
-- !query 8 schema
struct<i:int,j:int>
-- !query 8 output
1	2
2	3
3	4


-- !query 9
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r
)
SELECT * FROM r ORDER BY level
-- !query 9 schema
struct<>
-- !query 9 output
org.apache.spark.SparkException
Recursion level limit reached but query hasn't exhausted, try increasing spark.sql.cte.recursion.level.limit


-- !query 10
WITH RECURSIVE r AS (
  SELECT level + 1, data FROM r WHERE level < 10
  UNION ALL
  VALUES (0, 'A') AS T(level, data)
)
SELECT * FROM r ORDER BY level
-- !query 10 schema
struct<level:int,data:string>
-- !query 10 output
0	A
1	A
2	A
3	A
4	A
5	A
6	A
7	A
8	A
9	A
10	A


-- !query 11
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
  UNION ALL
  VALUES (0, 'B') AS T(level, data)
)
SELECT * FROM r ORDER BY level
-- !query 11 schema
struct<level:int,data:string>
-- !query 11 output
0	A
0	B
1	A
1	B
2	A
2	B
3	A
3	B


-- !query 12
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
)
SELECT * FROM r ORDER BY level
-- !query 12 schema
struct<level:int,data:string>
-- !query 12 output
0	A
1	A
1	A
2	A
2	A
2	A
2	A
3	A
3	A
3	A
3	A
3	A
3	A
3	A
3	A


-- !query 13
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  VALUES (0, 'B') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
)
SELECT * FROM r ORDER BY level
-- !query 13 schema
struct<level:int,data:string>
-- !query 13 output
0	A
0	B
1	A
1	B
1	A
1	B
2	A
2	B
2	A
2	B
2	A
2	B
2	A
2	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B


-- !query 14
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  INTERSECT
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 14 schema
struct<>
-- !query 14 output
org.apache.spark.sql.AnalysisException
Recursive query r should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 15
WITH RECURSIVE r AS (
  SELECT level + 1, data FROM r WHERE level < 3
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
)
SELECT * FROM r
-- !query 15 schema
struct<>
-- !query 15 output
org.apache.spark.sql.AnalysisException
There should be at least 1 anchor term defined in the recursive query r;


-- !query 16
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE (SELECT SUM(level) FROM r) < 10
)
SELECT * FROM r
-- !query 16 schema
struct<>
-- !query 16 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 17
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, r1.data
  FROM r AS r1
  JOIN r AS r2 ON r2.data = r1.data
)
SELECT * FROM r
-- !query 17 schema
struct<>
-- !query 17 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used multiple times in a recursive term;


-- !query 18
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, r.data
  FROM (SELECT 'B' AS data) AS o
  LEFT JOIN r ON r.data = o.data
)
SELECT * FROM r
-- !query 18 schema
struct<>
-- !query 18 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 19
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  RIGHT JOIN (SELECT 'B' AS data) AS o ON o.data = r.data
)
SELECT * FROM r
-- !query 19 schema
struct<>
-- !query 19 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 20
WITH RECURSIVE r AS (
  SELECT MAX(level) AS level, SUM(data) AS data FROM VALUES (0, 1), (0, 2) AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r ORDER BY level
-- !query 20 schema
struct<level:int,data:bigint>
-- !query 20 output
0	3
1	3
2	3
3	3
4	3
5	3
6	3
7	3
8	3
9	3
10	3


-- !query 21
WITH RECURSIVE r AS (
  VALUES (0, 1L) AS T(group, data)
  UNION ALL
  SELECT 1, SUM(data) FROM r WHERE data < 10 GROUP BY group
)
SELECT * FROM r
-- !query 21 schema
struct<>
-- !query 21 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 22
WITH RECURSIVE r AS (
  VALUES (1L) AS T(data)
  UNION ALL
  SELECT SUM(data) FROM r WHERE data < 10
)
SELECT * FROM r
-- !query 22 schema
struct<>
-- !query 22 output
org.apache.spark.sql.AnalysisException
Recursive reference r can't be used in an aggregate;


-- !query 23
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT COUNT(*) FROM r
-- !query 23 schema
struct<count(1):bigint>
-- !query 23 output
11


-- !query 24
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS T(level, data)
  UNION ALL
  SELECT DISTINCT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 24 schema
struct<>
-- !query 24 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 25
CREATE TEMPORARY VIEW department AS SELECT * FROM VALUES
  (0, null, 'ROOT'),
  (1, 0, 'A'),
  (2, 1, 'B'),
  (3, 2, 'C'),
  (4, 2, 'D'),
  (5, 0, 'E'),
  (6, 4, 'F'),
  (7, 5, 'G')
  AS department(id, parent_department, name)
-- !query 25 schema
struct<>
-- !query 25 output



-- !query 26
WITH RECURSIVE subdepartment AS (
	SELECT name as root_name, * FROM department WHERE name = 'A'
	UNION ALL
	SELECT sd.root_name, d.*
	FROM department AS d, subdepartment AS sd
	WHERE d.parent_department = sd.id
)
SELECT * FROM subdepartment ORDER BY name
-- !query 26 schema
struct<root_name:string,id:int,parent_department:int,name:string>
-- !query 26 output
A	1	0	A
A	2	1	B
A	3	2	C
A	4	2	D
A	6	4	F


-- !query 27
WITH RECURSIVE subdepartment AS (
	SELECT 1 as level, id, parent_department, name FROM department WHERE name = 'A'
	UNION ALL
	SELECT sd.level + 1, d.*
	FROM department AS d, subdepartment AS sd
	WHERE d.parent_department = sd.id
)
SELECT * FROM subdepartment ORDER BY name
-- !query 27 schema
struct<level:int,id:int,parent_department:int,name:string>
-- !query 27 output
1	1	0	A
2	2	1	B
3	3	2	C
3	4	2	D
4	6	4	F


-- !query 28
WITH RECURSIVE subdepartment AS (
	SELECT 1 as level, id, parent_department, name FROM department WHERE name = 'A'
	UNION ALL
	SELECT sd.level + 1, d.*
	FROM department AS d, subdepartment AS sd
	WHERE d.parent_department = sd.id
)
SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name
-- !query 28 schema
struct<level:int,id:int,parent_department:int,name:string>
-- !query 28 output
2	2	1	B
3	3	2	C
3	4	2	D
4	6	4	F


-- !query 29
WITH RECURSIVE subdepartment AS (
  SELECT * FROM department WHERE name = 'A'
  UNION ALL
  SELECT d.*
  FROM department AS d
  JOIN subdepartment AS sd ON (sd.parent_department = d.id)
)
SELECT id, name FROM subdepartment ORDER BY name
-- !query 29 schema
struct<id:int,name:string>
-- !query 29 output
1	A
0	ROOT


-- !query 30
WITH RECURSIVE subdepartment AS (
  SELECT * FROM department WHERE name = 'A'
)
SELECT * FROM subdepartment ORDER BY name
-- !query 30 schema
struct<id:int,parent_department:int,name:string>
-- !query 30 output
1	0	A


-- !query 31
CREATE TEMPORARY VIEW vsubdepartment AS
  WITH RECURSIVE subdepartment AS (
    SELECT * FROM department WHERE name = 'A'
	UNION ALL
	SELECT d.*
	FROM department AS d, subdepartment AS sd
	WHERE d.parent_department = sd.id
  )
  SELECT * FROM subdepartment
-- !query 31 schema
struct<>
-- !query 31 output



-- !query 32
SELECT * FROM vsubdepartment ORDER BY name
-- !query 32 schema
struct<id:int,parent_department:int,name:string>
-- !query 32 output
1	0	A
2	1	B
3	2	C
4	2	D
6	4	F


-- !query 33
CREATE TEMPORARY VIEW tree AS SELECT * FROM VALUES
  (1, NULL),
  (2, 1),
  (3, 1),
  (4, 2),
  (5, 2),
  (6, 2),
  (7, 3),
  (8, 3),
  (9, 4),
  (10, 4),
  (11, 7),
  (12, 7),
  (13, 7),
  (14, 9),
  (15, 11),
  (16, 11)
AS (id, parent_id)
-- !query 33 schema
struct<>
-- !query 33 output



-- !query 34
WITH RECURSIVE t AS (
  VALUES(1, ARRAY_REMOVE(ARRAY(0), 0)) AS T(id, path)
  UNION ALL
  SELECT tree.id, t.path || ARRAY(tree.id)
  FROM tree
  JOIN t ON tree.parent_id = t.id
)
SELECT t1.*, t2.*
FROM t AS t1
JOIN t AS t2 ON t1.path[0] = t2.path[0] AND SIZE(t1.path) = 1 AND SIZE(t2.path) > 1
ORDER BY t1.id, t2.id
-- !query 34 schema
struct<id:int,path:array<int>,id:int,path:array<int>>
-- !query 34 output
2	[2]	4	[2,4]
2	[2]	5	[2,5]
2	[2]	6	[2,6]
2	[2]	9	[2,4,9]
2	[2]	10	[2,4,10]
2	[2]	14	[2,4,9,14]
3	[3]	7	[3,7]
3	[3]	8	[3,8]
3	[3]	11	[3,7,11]
3	[3]	12	[3,7,12]
3	[3]	13	[3,7,13]
3	[3]	15	[3,7,11,15]
3	[3]	16	[3,7,11,16]


-- !query 35
WITH RECURSIVE t AS (
  VALUES(1, ARRAY_REMOVE(ARRAY(0), 0)) AS T(id, path)
  UNION ALL
  SELECT tree.id, t.path || ARRAY(tree.id)
  FROM tree
  JOIN t ON tree.parent_id = t.id
)
SELECT t1.id, COUNT(t2.*)
FROM t AS t1
JOIN t AS t2 ON t1.path[0] = t2.path[0] AND SIZE(t1.path) = 1 AND SIZE(t2.path) > 1
GROUP BY t1.id
ORDER BY t1.id
-- !query 35 schema
struct<id:int,count(id, path):bigint>
-- !query 35 output
2	6
3	7


-- !query 36
WITH RECURSIVE t AS (
  VALUES(1, ARRAY_REMOVE(ARRAY(0), 0)) AS T(id, path)
  UNION ALL
  SELECT tree.id, t.path || ARRAY(tree.id)
  FROM tree
  JOIN t ON tree.parent_id = t.id
)
SELECT t1.id, t2.path, STRUCT(t2.*)
FROM t AS t1
JOIN t AS t2 ON t1.id = t2.id
-- !query 36 schema
struct<id:int,path:array<int>,named_struct(id, id, path, path):struct<id:int,path:array<int>>>
-- !query 36 output
1	[]	{"id":1,"path":[]}
10	[2,4,10]	{"id":10,"path":[2,4,10]}
11	[3,7,11]	{"id":11,"path":[3,7,11]}
12	[3,7,12]	{"id":12,"path":[3,7,12]}
13	[3,7,13]	{"id":13,"path":[3,7,13]}
14	[2,4,9,14]	{"id":14,"path":[2,4,9,14]}
15	[3,7,11,15]	{"id":15,"path":[3,7,11,15]}
16	[3,7,11,16]	{"id":16,"path":[3,7,11,16]}
2	[2]	{"id":2,"path":[2]}
3	[3]	{"id":3,"path":[3]}
4	[2,4]	{"id":4,"path":[2,4]}
5	[2,5]	{"id":5,"path":[2,5]}
6	[2,6]	{"id":6,"path":[2,6]}
7	[3,7]	{"id":7,"path":[3,7]}
8	[3,8]	{"id":8,"path":[3,8]}
9	[2,4,9]	{"id":9,"path":[2,4,9]}


-- !query 37
CREATE TEMPORARY VIEW graph AS SELECT * FROM VALUES
  (1, 2, 'arc 1 -> 2'),
  (1, 3, 'arc 1 -> 3'),
  (2, 3, 'arc 2 -> 3'),
  (1, 4, 'arc 1 -> 4'),
  (4, 5, 'arc 4 -> 5'),
  (5, 1, 'arc 5 -> 1')
AS (f, t, label)
-- !query 37 schema
struct<>
-- !query 37 output



-- !query 38
WITH RECURSIVE search_graph AS (
  SELECT *, ARRAY(STRUCT(g.f, g.t)) AS path, false AS cycle FROM graph g
  UNION ALL
  SELECT g.*, path || ARRAY(STRUCT(g.f, g.t)), ARRAY_CONTAINS(path, STRUCT(g.f, g.t))
  FROM graph g, search_graph sg
  WHERE g.f = sg.t AND NOT cycle
)
SELECT * FROM search_graph
-- !query 38 schema
struct<f:int,t:int,label:string,path:array<struct<f:int,t:int>>,cycle:boolean>
-- !query 38 output
1	2	arc 1 -> 2	[{"f":1,"t":2}]	false
1	2	arc 1 -> 2	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
1	2	arc 1 -> 2	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
1	2	arc 1 -> 2	[{"f":5,"t":1},{"f":1,"t":2}]	false
1	3	arc 1 -> 3	[{"f":1,"t":3}]	false
1	3	arc 1 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	3	arc 1 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	3	arc 1 -> 3	[{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	true
1	4	arc 1 -> 4	[{"f":1,"t":4}]	false
1	4	arc 1 -> 4	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	false
1	4	arc 1 -> 4	[{"f":5,"t":1},{"f":1,"t":4}]	false
2	3	arc 2 -> 3	[{"f":1,"t":2},{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
4	5	arc 4 -> 5	[{"f":1,"t":4},{"f":4,"t":5}]	false
4	5	arc 4 -> 5	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	true
4	5	arc 4 -> 5	[{"f":4,"t":5}]	false
4	5	arc 4 -> 5	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	false
5	1	arc 5 -> 1	[{"f":4,"t":5},{"f":5,"t":1}]	false
5	1	arc 5 -> 1	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	true
5	1	arc 5 -> 1	[{"f":5,"t":1}]	false


-- !query 39
WITH RECURSIVE search_graph AS (
  SELECT *, ARRAY(STRUCT(g.f, g.t)) AS path, false AS cycle FROM graph g
  UNION ALL
  SELECT g.*, path || ARRAY(STRUCT(g.f, g.t)), ARRAY_CONTAINS(path, STRUCT(g.f, g.t))
  FROM graph g, search_graph sg
  WHERE g.f = sg.t AND NOT cycle
)
SELECT * FROM search_graph ORDER BY path
-- !query 39 schema
struct<f:int,t:int,label:string,path:array<struct<f:int,t:int>>,cycle:boolean>
-- !query 39 output
1	2	arc 1 -> 2	[{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":1,"t":4}]	false
4	5	arc 4 -> 5	[{"f":1,"t":4},{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	false
1	2	arc 1 -> 2	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	true
2	3	arc 2 -> 3	[{"f":2,"t":3}]	false
4	5	arc 4 -> 5	[{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":4,"t":5},{"f":5,"t":1}]	false
1	2	arc 1 -> 2	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	false
4	5	arc 4 -> 5	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	true
5	1	arc 5 -> 1	[{"f":5,"t":1}]	false
1	2	arc 1 -> 2	[{"f":5,"t":1},{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":5,"t":1},{"f":1,"t":4}]	false
4	5	arc 4 -> 5	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	true


-- !query 40
WITH RECURSIVE y AS (
  VALUES (1) AS T(id)
),
x AS (
  SELECT * FROM y
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
)
SELECT * FROM x
-- !query 40 schema
struct<id:int>
-- !query 40 output
1
2
3
4
5


-- !query 41
WITH RECURSIVE x AS (
  VALUES (1) AS T(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
),
y AS (
  VALUES (1) AS T(id)
  UNION ALL
  SELECT id + 1 FROM y WHERE id < 10
)
SELECT * FROM y LEFT JOIN x ON x.id = y.id
-- !query 41 schema
struct<id:int,id:int>
-- !query 41 output
1	1
10	NULL
2	2
3	3
4	4
5	5
6	NULL
7	NULL
8	NULL
9	NULL


-- !query 42
WITH RECURSIVE x AS (
  VALUES (1) AS T(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
),
y AS (
  VALUES (1) AS T(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 10
)
SELECT * FROM y LEFT JOIN x ON x.id = y.id
-- !query 42 schema
struct<id:int,id:int>
-- !query 42 output
1	1
2	2
3	3
4	4
5	5
6	NULL


-- !query 43
WITH RECURSIVE x AS (
  SELECT 1 AS id
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 3
),
y AS (
  SELECT * FROM x
  UNION ALL
  SELECT * FROM x
),
z AS (
  SELECT * FROM x
  UNION ALL
  SELECT id + 1 FROM z WHERE id < 10
)
SELECT * FROM z
-- !query 43 schema
struct<id:int>
-- !query 43 output
1
10
10
10
2
2
3
3
3
4
4
4
5
5
5
6
6
6
7
7
7
8
8
8
9
9
9


-- !query 44
WITH RECURSIVE x AS (
  SELECT 1 AS id
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 3
),
y AS (
  SELECT * FROM x
  UNION ALL
  SELECT * FROM x
),
z AS (
  SELECT * FROM y
  UNION ALL
  SELECT id + 1 FROM z WHERE id < 10
)
SELECT * FROM z
-- !query 44 schema
struct<id:int>
-- !query 44 output
1
1
10
10
10
10
10
10
2
2
2
2
3
3
3
3
3
3
4
4
4
4
4
4
5
5
5
5
5
5
6
6
6
6
6
6
7
7
7
7
7
7
8
8
8
8
8
8
9
9
9
9
9
9


-- !query 45
CREATE TEMPORARY VIEW routes AS SELECT * FROM VALUES
  ('New York', 'Washington'),
  ('New York', 'Boston'),
  ('Boston', 'New York'),
  ('Washington', 'Boston'),
  ('Washington', 'Raleigh')
  AS routes(origin, destination)
-- !query 45 schema
struct<>
-- !query 45 output



-- !query 46
WITH RECURSIVE destinations_from_new_york AS (
  SELECT 'New York' AS destination, ARRAY('New York') AS path, 0 AS length
  UNION ALL
  SELECT r.destination, CONCAT(d.path, ARRAY(r.destination)), d.length + 1
  FROM routes AS r
  JOIN destinations_from_new_york AS d ON d.destination = r.origin AND NOT ARRAY_CONTAINS(d.path, r.destination)
)
SELECT * FROM destinations_from_new_york
-- !query 46 schema
struct<destination:string,path:array<string>,length:int>
-- !query 46 output
Boston	["New York","Boston"]	1
Boston	["New York","Washington","Boston"]	2
New York	["New York"]	0
Raleigh	["New York","Washington","Raleigh"]	2
Washington	["New York","Washington"]	1


-- !query 47
WITH RECURSIVE fibonacci AS (
  VALUES (0, 1) AS T(a, b)
  UNION ALL
  SELECT b, a + b FROM fibonacci WHERE a < 10
)
SELECT a FROM fibonacci ORDER BY a
-- !query 47 schema
struct<a:int>
-- !query 47 output
0
1
1
2
3
5
8
13


-- !query 48
WITH RECURSIVE sudoku AS (
  VALUES (
    ARRAY(
      0, 0, 6, 0, 2, 3, 0, 0, 1,
      5, 0, 0, 0, 0, 0, 9, 0, 0,
      0, 0, 2, 0, 0, 4, 0, 0, 0,
      2, 0, 0, 8, 0, 0, 0, 9, 3,
      0, 0, 1, 0, 0, 7, 0, 0, 0,
      8, 3, 0, 0, 0, 0, 4, 0, 0,
      6, 0, 0, 1, 0, 0, 5, 0, 4,
      0, 5, 0, 0, 0, 0, 6, 0, 0,
      0, 0, 9, 0, 7, 0, 0, 2, 0
    ),
    0
  ) AS T(puzzle, level)
  UNION ALL
  SELECT
    CONCAT(SLICE(puzzle, 1, newPosition - 1), ARRAY(newValue), SLICE(puzzle, newPosition + 1, 9 * 9 - newPosition)),
    level + 1
  FROM (
    SELECT
      puzzle,
      newPosition,
      EXPLODE(allowedValues) AS newValue,
      level
    FROM (
      SELECT
        puzzle,
        newPosition,
        ARRAY_EXCEPT(
          ARRAY_EXCEPT(
            ARRAY_EXCEPT(
              SEQUENCE(1, 9),
              -- used values in row
              SLICE(puzzle, FLOOR((newPosition - 1) / 9) * 9 + 1, 9)
            ),
            -- used values in column
            TRANSFORM(puzzle, (x, i) -> IF(i % 9 = (newPosition - 1) % 9, x, 0))
          ),
          -- used values in 3x3 block
          TRANSFORM(
            SLICE(puzzle, FLOOR((newPosition - 1) / (3 * 9)) * 3 * 9 + 1, 3 * 9),
            (x, i) -> IF(FLOOR(i / 3) % 3 = FLOOR((newPosition - 1) / 3) % 3, x, 0)
          )
        ) AS allowedValues,
        level
      FROM sudoku
      JOIN (SELECT EXPLODE(SEQUENCE(1, 9 * 9)) AS newPosition) ON puzzle[newPosition - 1] = 0
      ORDER BY SIZE(allowedValues)
      LIMIT 1
    )
  )
)
SELECT * FROM sudoku WHERE NOT ARRAY_CONTAINS(puzzle, 0)
-- !query 48 schema
struct<puzzle:array<int>,level:int>
-- !query 48 output
[4,8,6,9,2,3,7,5,1,5,1,3,7,6,8,9,4,2,7,9,2,5,1,4,8,3,6,2,7,4,8,5,6,1,9,3,9,6,1,3,4,7,2,8,5,8,3,5,2,9,1,4,6,7,6,2,8,1,3,9,5,7,4,3,5,7,4,8,2,6,1,9,1,4,9,6,7,5,3,2,8]	55


-- !query 49
WITH RECURSIVE x AS (
  SELECT 1 AS n
  INTERSECT
  SELECT n + 1 FROM x
)
SELECT * FROM x
-- !query 49 schema
struct<>
-- !query 49 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 50
WITH RECURSIVE x AS (
  SELECT 1 AS n
  INTERSECT ALL
  SELECT n + 1 FROM x
)
SELECT * FROM x
-- !query 50 schema
struct<>
-- !query 50 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 51
WITH RECURSIVE x AS (
  SELECT 1 AS n
  EXCEPT
  SELECT n + 1 FROM x
)
SELECT * FROM x
-- !query 51 schema
struct<>
-- !query 51 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 52
WITH RECURSIVE x AS (
  SELECT 1 AS n
  EXCEPT ALL
  SELECT n + 1 FROM x
)
SELECT * FROM x
-- !query 52 schema
struct<>
-- !query 52 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 53
WITH RECURSIVE x AS (
 SELECT n FROM x
)
SELECT * FROM x
-- !query 53 schema
struct<>
-- !query 53 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 54
WITH RECURSIVE t AS (
  INSERT INTO y SELECT * FROM t
)
VALUES(FALSE)
-- !query 54 schema
struct<>
-- !query 54 output
org.apache.spark.sql.AnalysisException
Recursive query t should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 55
CREATE TEMPORARY VIEW y AS SELECT EXPLODE(SEQUENCE(1, 10)) AS a
-- !query 55 schema
struct<>
-- !query 55 output



-- !query 56
WITH RECURSIVE x AS (
  SELECT a AS n FROM y WHERE a = 1
  UNION ALL
  SELECT x.n + 1 FROM y LEFT JOIN x ON x.n = y.a WHERE n < 10
)
SELECT * FROM x
-- !query 56 schema
struct<>
-- !query 56 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 57
WITH RECURSIVE x AS (
  SELECT a AS n FROM y WHERE a = 1
  UNION ALL
  SELECT x.n + 1 FROM x RIGHT JOIN y ON x.n = y.a WHERE n < 10
)
SELECT * FROM x
-- !query 57 schema
struct<>
-- !query 57 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 58
WITH RECURSIVE x AS (
  SELECT a AS n FROM y WHERE a = 1
  UNION ALL
  SELECT x.n + 1 FROM x FULL JOIN y ON x.n = y.a WHERE n < 10
) SELECT * FROM x
-- !query 58 schema
struct<>
-- !query 58 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 59
WITH RECURSIVE x AS (
  SELECT 1 AS n
  UNION ALL
  SELECT n + 1
  FROM x
  WHERE n IN (SELECT * FROM x)
)
SELECT * FROM x
-- !query 59 schema
struct<>
-- !query 59 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 60
WITH RECURSIVE x AS (
  SELECT 1 AS n
  UNION ALL
  SELECT COUNT(*) FROM x
)
SELECT * FROM x
-- !query 60 schema
struct<>
-- !query 60 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 61
WITH RECURSIVE x AS (
  SELECT 1 AS n
  UNION ALL
  SELECT SUM(n) FROM x
)
SELECT * FROM x
-- !query 61 schema
struct<>
-- !query 61 output
org.apache.spark.sql.AnalysisException
Recursive reference x can't be used in an aggregate;


-- !query 62
WITH RECURSIVE x AS (
  SELECT 1 AS n
  UNION ALL
  SELECT n + 1 FROM x
  ORDER BY 1
)
SELECT * FROM x
-- !query 62 schema
struct<>
-- !query 62 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 63
WITH RECURSIVE x AS (
  SELECT 1 AS n
  UNION ALL
  SELECT n + 1 FROM x
  LIMIT 10
)
SELECT * FROM x
-- !query 63 schema
struct<>
-- !query 63 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 64
WITH RECURSIVE x AS (
  VALUES (1) AS T(id)
  UNION ALL
  SELECT (
    SELECT * FROM x
  )
  FROM x
  WHERE id < 5
)
SELECT * FROM x
-- !query 64 schema
struct<>
-- !query 64 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 65
WITH RECURSIVE x AS (
  SELECT 1 AS id
  UNION ALL
  SELECT id + 1 FROM y WHERE id < 5
),
y AS (
  SELECT 1 AS id
  UNION ALL
  SELECT id + 1
  FROM x
  WHERE id < 5
)
SELECT * FROM x
-- !query 65 schema
struct<>
-- !query 65 output
org.apache.spark.sql.AnalysisException
cannot resolve '`id`' given input columns: [y.a]; line 4 pos 29


-- !query 66
WITH RECURSIVE foo AS (
  VALUES (1) AS T(i)
  UNION ALL
  SELECT i + 1 FROM foo WHERE i < 10
  UNION ALL
  SELECT i + 1 FROM foo WHERE i < 5
)
SELECT i, COUNT(*) FROM foo GROUP BY i ORDER BY i
-- !query 66 schema
struct<i:int,count(1):bigint>
-- !query 66 output
1	1
2	2
3	4
4	8
5	16
6	16
7	16
8	16
9	16
10	16


-- !query 67
WITH RECURSIVE foo AS (
  VALUES (1) AS T(i)
  UNION ALL
  SELECT * FROM (
    SELECT i + 1
    FROM foo WHERE i < 10
    UNION ALL
    SELECT i + 1
    FROM foo WHERE i < 5
  ) AS t
)
SELECT i, COUNT(*) FROM foo GROUP BY i ORDER BY i
-- !query 67 schema
struct<>
-- !query 67 output
org.apache.spark.sql.AnalysisException
Recursive reference foo cannot be used multiple times in a recursive term;


-- !query 68
WITH RECURSIVE foo AS (
  VALUES (1) AS T(i)
  UNION ALL (
    SELECT i + 1 FROM foo WHERE i < 10
    EXCEPT
    SELECT i + 1 FROM foo WHERE i < 5
  )
)
SELECT * FROM foo
-- !query 68 schema
struct<>
-- !query 68 output
org.apache.spark.sql.AnalysisException
Recursive reference foo cannot be used multiple times in a recursive term;


-- !query 69
WITH RECURSIVE foo AS (
  VALUES (1) AS T(i)
  UNION ALL (
    SELECT i + 1 FROM foo WHERE i < 10
    INTERSECT
    SELECT i + 1 FROM foo WHERE i < 5
  )
)
SELECT * FROM foo
-- !query 69 schema
struct<>
-- !query 69 output
org.apache.spark.sql.AnalysisException
Recursive reference foo cannot be used multiple times in a recursive term;


-- !query 70
WITH RECURSIVE foo AS (
  VALUES (1), (2) AS T(i)
  UNION ALL
  SELECT CAST((i + 1) AS DECIMAL(10, 0)) FROM foo WHERE i < 10
)
SELECT * FROM foo
-- !query 70 schema
struct<>
-- !query 70 output
org.apache.spark.sql.AnalysisException
Anchor term types List(IntegerType) and recursive term types List(DecimalType(10,0)) doesn't match;


-- !query 71
WITH RECURSIVE foo AS (
   SELECT CAST(i AS DECIMAL(3, 0)) FROM (VALUES (1), (2)) AS T(i)
   UNION ALL
   SELECT CAST((i + 1) AS DECIMAL(10, 0)) FROM foo WHERE i < 10
)
SELECT * FROM foo
-- !query 71 schema
struct<>
-- !query 71 output
org.apache.spark.sql.AnalysisException
Anchor term types List(DecimalType(3,0)) and recursive term types List(DecimalType(10,0)) doesn't match;


-- !query 72
WITH RECURSIVE t AS (
  WITH RECURSIVE s AS (
    VALUES (1) AS T(i)
    UNION ALL
    SELECT i + 1 FROM s WHERE i < 10
  )
  SELECT i AS j FROM s
  UNION ALL
  SELECT j + 1 FROM t WHERE j < 10
)
SELECT * FROM t
-- !query 72 schema
struct<j:int>
-- !query 72 output
1
10
10
10
10
10
10
10
10
10
10
2
2
3
3
3
4
4
4
4
5
5
5
5
5
6
6
6
6
6
6
7
7
7
7
7
7
7
8
8
8
8
8
8
8
8
9
9
9
9
9
9
9
9
9


-- !query 73
WITH RECURSIVE outermost AS (
  WITH innermost AS (
    SELECT * FROM outermost
  )
  SELECT level + 1 FROM innermost WHERE level < 5
  UNION ALL
  SELECT 0 AS level
)
SELECT * FROM outermost
-- !query 73 schema
struct<level:int>
-- !query 73 output
0
1
2
3
4
5

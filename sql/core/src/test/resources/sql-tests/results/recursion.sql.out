-- Automatically generated by SQLQueryTestSuite
-- Number of queries: 86


-- !query 0
WITH r AS (
  VALUES (0, 'A') AS t(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 0 schema
struct<>
-- !query 0 output
org.apache.spark.sql.AnalysisException
Table or view not found: r; line 4 pos 30


-- !query 1
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS t(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r ORDER BY level
-- !query 1 schema
struct<level:int,data:string>
-- !query 1 output
0	A
1	A
2	A
3	A
4	A
5	A
6	A
7	A
8	A
9	A
10	A


-- !query 2
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS t(level, data)
  UNION ALL
  SELECT level + 1, data FROM r
)
SELECT * FROM r ORDER BY level
-- !query 2 schema
struct<>
-- !query 2 output
org.apache.spark.SparkException
Recursion level limit 100 reached but query has not exhausted, try increasing spark.sql.cte.recursion.level.limit


-- !query 3
WITH RECURSIVE t AS (
  VALUES (1) AS t(n)
  UNION ALL
  SELECT n + 1 FROM t WHERE n < 100
)
SELECT SUM(n) FROM t
-- !query 3 schema
struct<sum(n):bigint>
-- !query 3 output
5050


-- !query 4
WITH RECURSIVE t AS (
  SELECT (VALUES(1)) AS n
  UNION ALL
  SELECT n + 1 FROM t WHERE n < 5
)
SELECT * FROM t ORDER BY n
-- !query 4 schema
struct<n:int>
-- !query 4 output
1
2
3
4
5


-- !query 5
WITH RECURSIVE t AS (
  VALUES (1) AS t(n)
  UNION ALL
  SELECT n + 1 FROM t
)
SELECT * FROM t LIMIT 10
-- !query 5 schema
struct<n:int>
-- !query 5 output
1
10
2
3
4
5
6
7
8
9


-- !query 6
WITH RECURSIVE t AS (
  VALUES (1) AS t(n)
  UNION ALL
  SELECT n + 1 FROM t
)
SELECT n, n FROM t LIMIT 10
-- !query 6 schema
struct<n:int,n:int>
-- !query 6 output
1	1
10	10
2	2
3	3
4	4
5	5
6	6
7	7
8	8
9	9


-- !query 7
WITH RECURSIVE t AS (
  VALUES (1) AS t(n)
  UNION ALL
  SELECT n + 1 FROM t
)
SELECT SUM(n) FROM t LIMIT 10
-- !query 7 schema
struct<>
-- !query 7 output
org.apache.spark.SparkException
Recursion level limit 100 reached but query has not exhausted, try increasing spark.sql.cte.recursion.level.limit


-- !query 8
WITH RECURSIVE t AS (
  VALUES (1) AS t(n)
  UNION ALL
  SELECT n + 1 FROM t
)
SELECT n, n FROM t ORDER BY n LIMIT 10
-- !query 8 schema
struct<>
-- !query 8 output
org.apache.spark.SparkException
Recursion level limit 100 reached but query has not exhausted, try increasing spark.sql.cte.recursion.level.limit


-- !query 9
WITH RECURSIVE t AS (
  SELECT 'foo' AS n
  UNION ALL
  SELECT n || ' bar' FROM t WHERE LENGTH(n) < 20
)
SELECT n FROM t
-- !query 9 schema
struct<n:string>
-- !query 9 output
foo
foo bar
foo bar bar
foo bar bar bar
foo bar bar bar bar
foo bar bar bar bar bar


-- !query 10
WITH RECURSIVE t AS (
  VALUES (1, 2) AS t(i, j)
  UNION ALL
  SELECT t2.i, t.j + 1
  FROM (
    SELECT 2 AS i
    UNION ALL
    SELECT 3 AS i
  ) AS t2
  JOIN t ON (t2.i = t.i + 1)
)
SELECT * FROM t
-- !query 10 schema
struct<i:int,j:int>
-- !query 10 output
1	2
2	3
3	4


-- !query 11
WITH RECURSIVE r AS (
  SELECT level + 1, data FROM r WHERE level < 10
  UNION ALL
  VALUES (0, 'A') AS t(level, data)
)
SELECT * FROM r ORDER BY level
-- !query 11 schema
struct<level:int,data:string>
-- !query 11 output
0	A
1	A
2	A
3	A
4	A
5	A
6	A
7	A
8	A
9	A
10	A


-- !query 12
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS t(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
  UNION ALL
  VALUES (0, 'B') AS t(level, data)
)
SELECT * FROM r ORDER BY level
-- !query 12 schema
struct<level:int,data:string>
-- !query 12 output
0	A
0	B
1	A
1	B
2	A
2	B
3	A
3	B


-- !query 13
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS t(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
)
SELECT * FROM r ORDER BY level
-- !query 13 schema
struct<level:int,data:string>
-- !query 13 output
0	A
1	A
1	A
2	A
2	A
2	A
2	A
3	A
3	A
3	A
3	A
3	A
3	A
3	A
3	A


-- !query 14
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS t(level, data)
  UNION ALL
  VALUES (0, 'B') AS t(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
)
SELECT * FROM r ORDER BY level
-- !query 14 schema
struct<level:int,data:string>
-- !query 14 output
0	A
0	B
1	A
1	B
1	A
1	B
2	A
2	B
2	A
2	B
2	A
2	B
2	A
2	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B
3	A
3	B


-- !query 15
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS t(level, data)
  INTERSECT
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 15 schema
struct<>
-- !query 15 output
org.apache.spark.sql.AnalysisException
Recursive query r should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 16
WITH RECURSIVE r AS (
  SELECT level + 1, data FROM r WHERE level < 3
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 3
)
SELECT * FROM r
-- !query 16 schema
struct<>
-- !query 16 output
org.apache.spark.sql.AnalysisException
There should be at least one anchor term defined in the recursive query r;


-- !query 17
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS t(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE (
    SELECT SUM(level) FROM r
  ) < 10
)
SELECT * FROM r
-- !query 17 schema
struct<>
-- !query 17 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 18
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS t(level, data)
  UNION ALL
  SELECT r1.level + 1, r1.data
  FROM r AS r1
  JOIN r AS r2 ON r2.data = r1.data
)
SELECT * FROM r
-- !query 18 schema
struct<>
-- !query 18 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used multiple times in a recursive term;


-- !query 19
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS t(level, data)
  UNION ALL
  SELECT level + 1, r.data
  FROM (
    SELECT 'B' AS data
  ) AS o
  LEFT JOIN r ON r.data = o.data
)
SELECT * FROM r
-- !query 19 schema
struct<>
-- !query 19 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 20
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS t(level, data)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  RIGHT JOIN (
    SELECT 'B' AS data
  ) AS o ON o.data = r.data
)
SELECT * FROM r
-- !query 20 schema
struct<>
-- !query 20 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 21
WITH RECURSIVE r AS (
  SELECT MAX(level) AS level, SUM(data) AS data FROM VALUES (0, 1), (0, 2) AS t(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r ORDER BY level
-- !query 21 schema
struct<level:int,data:bigint>
-- !query 21 output
0	3
1	3
2	3
3	3
4	3
5	3
6	3
7	3
8	3
9	3
10	3


-- !query 22
WITH RECURSIVE r AS (
  VALUES (0, 1L) AS t(group, data)
  UNION ALL
  SELECT 1, SUM(data) FROM r WHERE data < 10 GROUP BY group
)
SELECT * FROM r
-- !query 22 schema
struct<>
-- !query 22 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 23
WITH RECURSIVE r AS (
  VALUES (1L) AS t(data)
  UNION ALL
  SELECT SUM(data) FROM r WHERE data < 10
)
SELECT * FROM r
-- !query 23 schema
struct<>
-- !query 23 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 24
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS t(level, data)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT COUNT(*) FROM r
-- !query 24 schema
struct<count(1):bigint>
-- !query 24 output
11


-- !query 25
WITH RECURSIVE r AS (
  VALUES (0, 'A') AS t(level, data)
  UNION ALL
  SELECT DISTINCT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 25 schema
struct<>
-- !query 25 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 26
WITH RECURSIVE y AS (
  VALUES (1) AS t(id)
),
x AS (
  SELECT * FROM y
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
)
SELECT * FROM x
-- !query 26 schema
struct<id:int>
-- !query 26 output
1
2
3
4
5


-- !query 27
WITH RECURSIVE x AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
),
y AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM y WHERE id < 10
)
SELECT * FROM y LEFT JOIN x ON x.id = y.id
-- !query 27 schema
struct<id:int,id:int>
-- !query 27 output
1	1
10	NULL
2	2
3	3
4	4
5	5
6	NULL
7	NULL
8	NULL
9	NULL


-- !query 28
WITH RECURSIVE x AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
),
y AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 10
)
SELECT * FROM y LEFT JOIN x ON x.id = y.id
-- !query 28 schema
struct<id:int,id:int>
-- !query 28 output
1	1
2	2
3	3
4	4
5	5
6	NULL


-- !query 29
WITH RECURSIVE x AS (
  SELECT 1 AS id
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 3
),
y AS (
  SELECT * FROM x
  UNION ALL
  SELECT * FROM x
),
z AS (
  SELECT * FROM x
  UNION ALL
  SELECT id + 1 FROM z WHERE id < 10
)
SELECT * FROM z
-- !query 29 schema
struct<id:int>
-- !query 29 output
1
10
10
10
2
2
3
3
3
4
4
4
5
5
5
6
6
6
7
7
7
8
8
8
9
9
9


-- !query 30
WITH RECURSIVE x AS (
  SELECT 1 AS id
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 3
),
y AS (
  SELECT * FROM x
  UNION ALL
  SELECT * FROM x
),
z AS (
  SELECT * FROM y
  UNION ALL
  SELECT id + 1 FROM z WHERE id < 10
)
SELECT * FROM z
-- !query 30 schema
struct<id:int>
-- !query 30 output
1
1
10
10
10
10
10
10
2
2
2
2
3
3
3
3
3
3
4
4
4
4
4
4
5
5
5
5
5
5
6
6
6
6
6
6
7
7
7
7
7
7
8
8
8
8
8
8
9
9
9
9
9
9


-- !query 31
WITH RECURSIVE x AS (
  SELECT 1 AS n
  INTERSECT
  SELECT n + 1 FROM x
)
SELECT * FROM x
-- !query 31 schema
struct<>
-- !query 31 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 32
WITH RECURSIVE x AS (
  SELECT 1 AS n
  INTERSECT ALL
  SELECT n + 1 FROM x
)
SELECT * FROM x
-- !query 32 schema
struct<>
-- !query 32 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 33
WITH RECURSIVE x AS (
  SELECT 1 AS n
  EXCEPT
  SELECT n + 1 FROM x
)
SELECT * FROM x
-- !query 33 schema
struct<>
-- !query 33 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 34
WITH RECURSIVE x AS (
  SELECT 1 AS n
  EXCEPT ALL
  SELECT n + 1 FROM x
)
SELECT * FROM x
-- !query 34 schema
struct<>
-- !query 34 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 35
WITH RECURSIVE x AS (
 SELECT n FROM x
)
SELECT * FROM x
-- !query 35 schema
struct<>
-- !query 35 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 36
WITH RECURSIVE t AS (
  INSERT INTO y SELECT * FROM t
)
VALUES(FALSE)
-- !query 36 schema
struct<>
-- !query 36 output
org.apache.spark.sql.AnalysisException
Recursive query t should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 37
CREATE TEMPORARY VIEW data AS SELECT EXPLODE(SEQUENCE(1, 10)) AS a
-- !query 37 schema
struct<>
-- !query 37 output



-- !query 38
WITH RECURSIVE x AS (
  SELECT a AS n FROM data WHERE a = 1
  UNION ALL
  SELECT x.n + 1 FROM data LEFT JOIN x ON x.n = data.a WHERE n < 10
)
SELECT * FROM x
-- !query 38 schema
struct<>
-- !query 38 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 39
WITH RECURSIVE x AS (
  SELECT a AS n FROM data WHERE a = 1
  UNION ALL
  SELECT x.n + 1 FROM x RIGHT JOIN data ON x.n = data.a WHERE n < 10
)
SELECT * FROM x
-- !query 39 schema
struct<>
-- !query 39 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 40
WITH RECURSIVE x AS (
  SELECT a AS n FROM data WHERE a = 1
  UNION ALL
  SELECT x.n + 1 FROM x FULL JOIN data ON x.n = data.a WHERE n < 10
) SELECT * FROM x
-- !query 40 schema
struct<>
-- !query 40 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 41
WITH RECURSIVE x AS (
  SELECT a AS n FROM data WHERE a = 1
  UNION ALL
  SELECT x.n + 1
  FROM x
  JOIN data AS d1 ON d1.a = x.n
  JOIN data AS d2 ON d2.a = x.n
  WHERE n < 10
)
SELECT * FROM x
-- !query 41 schema
struct<n:int>
-- !query 41 output
1
10
2
3
4
5
6
7
8
9


-- !query 42
DROP VIEW data
-- !query 42 schema
struct<>
-- !query 42 output



-- !query 43
WITH RECURSIVE x AS (
  SELECT 1 AS n
  UNION ALL
  SELECT n + 1
  FROM x
  WHERE n IN (SELECT * FROM x)
)
SELECT * FROM x
-- !query 43 schema
struct<>
-- !query 43 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 44
WITH RECURSIVE x AS (
  SELECT 1L AS n
  UNION ALL
  SELECT COUNT(*) FROM x
)
SELECT * FROM x
-- !query 44 schema
struct<>
-- !query 44 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 45
WITH RECURSIVE x AS (
  SELECT 1L AS n
  UNION ALL
  SELECT SUM(n) FROM x
)
SELECT * FROM x
-- !query 45 schema
struct<>
-- !query 45 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 46
WITH RECURSIVE x AS (
  SELECT 1 AS n
  UNION ALL
  SELECT n + 1 FROM x
  ORDER BY 1
)
SELECT * FROM x
-- !query 46 schema
struct<>
-- !query 46 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 47
WITH RECURSIVE x AS (
  SELECT 1 AS n
  UNION ALL
  SELECT n + 1 FROM x
  LIMIT 10
)
SELECT * FROM x
-- !query 47 schema
struct<>
-- !query 47 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION ALL statements only. This can also be caused by ORDER BY or LIMIT keywords used on result of UNION ALL.;


-- !query 48
WITH RECURSIVE x AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT (
    SELECT * FROM x
  )
  FROM x
  WHERE id < 5
)
SELECT * FROM x
-- !query 48 schema
struct<>
-- !query 48 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it in a different join than inner or left outer or right outer, using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term.;


-- !query 49
WITH RECURSIVE x AS (
  SELECT 1 AS id
  UNION ALL
  SELECT id + 1 FROM y WHERE id < 5
),
y AS (
  SELECT 1 AS id
  UNION ALL
  SELECT id + 1
  FROM x
  WHERE id < 5
)
SELECT * FROM x
-- !query 49 schema
struct<>
-- !query 49 output
org.apache.spark.sql.AnalysisException
Table or view not found: y; line 4 pos 21


-- !query 50
WITH RECURSIVE foo AS (
  VALUES (1) AS t(i)
  UNION ALL
  SELECT i + 1 FROM foo WHERE i < 10
  UNION ALL
  SELECT i + 1 FROM foo WHERE i < 5
)
SELECT i, COUNT(*) FROM foo GROUP BY i ORDER BY i
-- !query 50 schema
struct<i:int,count(1):bigint>
-- !query 50 output
1	1
2	2
3	4
4	8
5	16
6	16
7	16
8	16
9	16
10	16


-- !query 51
WITH RECURSIVE foo AS (
  VALUES (1) AS t(i)
  UNION ALL
  SELECT * FROM (
    SELECT i + 1
    FROM foo WHERE i < 10
    UNION ALL
    SELECT i + 1
    FROM foo WHERE i < 5
  ) AS t
)
SELECT i, COUNT(*) FROM foo GROUP BY i ORDER BY i
-- !query 51 schema
struct<>
-- !query 51 output
org.apache.spark.sql.AnalysisException
Recursive reference foo cannot be used multiple times in a recursive term;


-- !query 52
WITH RECURSIVE foo AS (
  VALUES (1) AS t(i)
  UNION ALL (
    SELECT i + 1 FROM foo WHERE i < 10
    EXCEPT
    SELECT i + 1 FROM foo WHERE i < 5
  )
)
SELECT * FROM foo
-- !query 52 schema
struct<>
-- !query 52 output
org.apache.spark.sql.AnalysisException
Recursive reference foo cannot be used multiple times in a recursive term;


-- !query 53
WITH RECURSIVE foo AS (
  VALUES (1) AS t(i)
  UNION ALL (
    SELECT i + 1 FROM foo WHERE i < 10
    INTERSECT
    SELECT i + 1 FROM foo WHERE i < 5
  )
)
SELECT * FROM foo
-- !query 53 schema
struct<>
-- !query 53 output
org.apache.spark.sql.AnalysisException
Recursive reference foo cannot be used multiple times in a recursive term;


-- !query 54
WITH RECURSIVE foo AS (
  VALUES (1), (2) AS t(i)
  UNION ALL
  SELECT CAST((i + 1) AS DECIMAL(10, 0)) FROM foo WHERE i < 10
)
SELECT * FROM foo
-- !query 54 schema
struct<>
-- !query 54 output
org.apache.spark.sql.AnalysisException
Recursive table foo term types List(IntegerType) and List(DecimalType(10,0)) do not match;


-- !query 55
WITH RECURSIVE foo AS (
   SELECT CAST(i AS DECIMAL(3, 0)) FROM (VALUES (1), (2)) AS t(i)
   UNION ALL
   SELECT CAST((i + 1) AS DECIMAL(10, 0)) FROM foo WHERE i < 10
)
SELECT * FROM foo
-- !query 55 schema
struct<>
-- !query 55 output
org.apache.spark.sql.AnalysisException
Recursive table foo term types List(DecimalType(3,0)) and List(DecimalType(10,0)) do not match;


-- !query 56
WITH t AS (
  WITH RECURSIVE s AS (
    VALUES (1) AS t(i)
    UNION ALL
    SELECT i + 1 FROM s
  )
  SELECT i AS j FROM s LIMIT 10
)
SELECT * FROM t
-- !query 56 schema
struct<j:int>
-- !query 56 output
1
10
2
3
4
5
6
7
8
9


-- !query 57
WITH RECURSIVE outermost AS (
  WITH innermost AS (
    SELECT * FROM outermost
  )
  SELECT level + 1 FROM innermost WHERE level < 5
  UNION ALL
  SELECT 0 AS level
)
SELECT * FROM outermost
-- !query 57 schema
struct<level:int>
-- !query 57 output
0
1
2
3
4
5


-- !query 58
WITH RECURSIVE t AS (
  WITH RECURSIVE s AS (
    VALUES (1) AS t(i)
    UNION ALL
    SELECT i + 1 FROM s WHERE i < 10
  )
  SELECT i AS j FROM s
  UNION ALL
  SELECT j + 1 FROM t WHERE j < 10
)
SELECT * FROM t
-- !query 58 schema
struct<j:int>
-- !query 58 output
1
10
10
10
10
10
10
10
10
10
10
2
2
3
3
3
4
4
4
4
5
5
5
5
5
6
6
6
6
6
6
7
7
7
7
7
7
7
8
8
8
8
8
8
8
8
9
9
9
9
9
9
9
9
9


-- !query 59
WITH RECURSIVE t AS (
  WITH RECURSIVE s AS (
    SELECT j, 1 AS i FROM t
    UNION ALL
    SELECT j, i + 1 FROM s WHERE i < 3
  )
  VALUES (1) as t(j)
  UNION ALL
  SELECT j + 1 FROM s WHERE j < 3
)
SELECT * FROM t
-- !query 59 schema
struct<j:int>
-- !query 59 output
1
2
2
2
3
3
3
3
3
3
3
3
3


-- !query 60
WITH RECURSIVE t AS (
  WITH RECURSIVE t AS (
    SELECT j, 1 AS i FROM t
    UNION ALL
    SELECT j, i + 1 FROM t WHERE i < 3
  )
  VALUES (1) as t(j)
  UNION ALL
  SELECT j + 1 FROM t WHERE j < 3
)
SELECT * FROM t
-- !query 60 schema
struct<j:int>
-- !query 60 output
1
2
3


-- !query 61
CREATE TEMPORARY VIEW sums_1_100 AS
WITH RECURSIVE t AS (
  VALUES (1) AS t(n)
  UNION ALL
  SELECT n + 1 FROM t WHERE n < 100
)
SELECT SUM(n) FROM t
-- !query 61 schema
struct<>
-- !query 61 output



-- !query 62
SELECT * FROM sums_1_100
-- !query 62 schema
struct<sum(n):bigint>
-- !query 62 output
5050


-- !query 63
CREATE TEMPORARY VIEW department AS SELECT * FROM VALUES
  (0, null, 'ROOT'),
  (1, 0, 'A'),
  (2, 1, 'B'),
  (3, 2, 'C'),
  (4, 2, 'D'),
  (5, 0, 'E'),
  (6, 4, 'F'),
  (7, 5, 'G')
  AS department(id, parent_department, name)
-- !query 63 schema
struct<>
-- !query 63 output



-- !query 64
WITH RECURSIVE subdepartment AS (
  SELECT name AS root_name, * FROM department WHERE name = 'A'
  UNION ALL
  SELECT sd.root_name, d.*
  FROM department AS d, subdepartment AS sd
  WHERE d.parent_department = sd.id
)
SELECT * FROM subdepartment ORDER BY name
-- !query 64 schema
struct<root_name:string,id:int,parent_department:int,name:string>
-- !query 64 output
A	1	0	A
A	2	1	B
A	3	2	C
A	4	2	D
A	6	4	F


-- !query 65
WITH RECURSIVE subdepartment AS (
  SELECT 1 AS level, id, parent_department, name FROM department WHERE name = 'A'
  UNION ALL
  SELECT sd.level + 1, d.*
  FROM department AS d, subdepartment AS sd
  WHERE d.parent_department = sd.id
)
SELECT * FROM subdepartment ORDER BY name
-- !query 65 schema
struct<level:int,id:int,parent_department:int,name:string>
-- !query 65 output
1	1	0	A
2	2	1	B
3	3	2	C
3	4	2	D
4	6	4	F


-- !query 66
WITH RECURSIVE subdepartment AS (
  SELECT 1 AS level, id, parent_department, name FROM department WHERE name = 'A'
  UNION ALL
  SELECT sd.level + 1, d.*
  FROM department AS d, subdepartment AS sd
  WHERE d.parent_department = sd.id
)
SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name
-- !query 66 schema
struct<level:int,id:int,parent_department:int,name:string>
-- !query 66 output
2	2	1	B
3	3	2	C
3	4	2	D
4	6	4	F


-- !query 67
WITH RECURSIVE subdepartment AS (
  SELECT * FROM department WHERE name = 'A'
  UNION ALL
  SELECT d.*
  FROM department AS d
  JOIN subdepartment AS sd ON (sd.parent_department = d.id)
)
SELECT id, name FROM subdepartment ORDER BY name
-- !query 67 schema
struct<id:int,name:string>
-- !query 67 output
1	A
0	ROOT


-- !query 68
WITH RECURSIVE subdepartment AS (
  SELECT * FROM department WHERE name = 'A'
)
SELECT * FROM subdepartment ORDER BY name
-- !query 68 schema
struct<id:int,parent_department:int,name:string>
-- !query 68 output
1	0	A


-- !query 69
CREATE TEMPORARY VIEW vsubdepartment AS
  WITH RECURSIVE subdepartment AS (
    SELECT * FROM department WHERE name = 'A'
  UNION ALL
  SELECT d.*
  FROM department AS d, subdepartment AS sd
  WHERE d.parent_department = sd.id
  )
  SELECT * FROM subdepartment
-- !query 69 schema
struct<>
-- !query 69 output



-- !query 70
SELECT * FROM vsubdepartment ORDER BY name
-- !query 70 schema
struct<id:int,parent_department:int,name:string>
-- !query 70 output
1	0	A
2	1	B
3	2	C
4	2	D
6	4	F


-- !query 71
DROP VIEW department
-- !query 71 schema
struct<>
-- !query 71 output



-- !query 72
CREATE TEMPORARY VIEW tree AS SELECT * FROM VALUES
  (1, NULL),
  (2, 1),
  (3, 1),
  (4, 2),
  (5, 2),
  (6, 2),
  (7, 3),
  (8, 3),
  (9, 4),
  (10, 4),
  (11, 7),
  (12, 7),
  (13, 7),
  (14, 9),
  (15, 11),
  (16, 11)
AS (id, parent_id)
-- !query 72 schema
struct<>
-- !query 72 output



-- !query 73
WITH RECURSIVE t AS (
  VALUES(1, ARRAY_REMOVE(ARRAY(0), 0)) AS t(id, path)
  UNION ALL
  SELECT tree.id, t.path || ARRAY(tree.id)
  FROM tree
  JOIN t ON tree.parent_id = t.id
)
SELECT t1.*, t2.*
FROM t AS t1
JOIN t AS t2 ON t1.path[0] = t2.path[0] AND SIZE(t1.path) = 1 AND SIZE(t2.path) > 1
ORDER BY t1.id, t2.id
-- !query 73 schema
struct<id:int,path:array<int>,id:int,path:array<int>>
-- !query 73 output
2	[2]	4	[2,4]
2	[2]	5	[2,5]
2	[2]	6	[2,6]
2	[2]	9	[2,4,9]
2	[2]	10	[2,4,10]
2	[2]	14	[2,4,9,14]
3	[3]	7	[3,7]
3	[3]	8	[3,8]
3	[3]	11	[3,7,11]
3	[3]	12	[3,7,12]
3	[3]	13	[3,7,13]
3	[3]	15	[3,7,11,15]
3	[3]	16	[3,7,11,16]


-- !query 74
WITH RECURSIVE t AS (
  VALUES(1, ARRAY_REMOVE(ARRAY(0), 0)) AS t(id, path)
  UNION ALL
  SELECT tree.id, t.path || ARRAY(tree.id)
  FROM tree
  JOIN t ON tree.parent_id = t.id
)
SELECT t1.id, COUNT(t2.*)
FROM t AS t1
JOIN t AS t2 ON t1.path[0] = t2.path[0] AND SIZE(t1.path) = 1 AND SIZE(t2.path) > 1
GROUP BY t1.id
ORDER BY t1.id
-- !query 74 schema
struct<id:int,count(id, path):bigint>
-- !query 74 output
2	6
3	7


-- !query 75
WITH RECURSIVE t AS (
  VALUES(1, ARRAY_REMOVE(ARRAY(0), 0)) AS t(id, path)
  UNION ALL
  SELECT tree.id, t.path || ARRAY(tree.id)
  FROM tree
  JOIN t ON tree.parent_id = t.id
)
SELECT t1.id, t2.path, STRUCT(t2.*)
FROM t AS t1
JOIN t AS t2 ON t1.id = t2.id
-- !query 75 schema
struct<id:int,path:array<int>,named_struct(id, id, path, path):struct<id:int,path:array<int>>>
-- !query 75 output
1	[]	{"id":1,"path":[]}
10	[2,4,10]	{"id":10,"path":[2,4,10]}
11	[3,7,11]	{"id":11,"path":[3,7,11]}
12	[3,7,12]	{"id":12,"path":[3,7,12]}
13	[3,7,13]	{"id":13,"path":[3,7,13]}
14	[2,4,9,14]	{"id":14,"path":[2,4,9,14]}
15	[3,7,11,15]	{"id":15,"path":[3,7,11,15]}
16	[3,7,11,16]	{"id":16,"path":[3,7,11,16]}
2	[2]	{"id":2,"path":[2]}
3	[3]	{"id":3,"path":[3]}
4	[2,4]	{"id":4,"path":[2,4]}
5	[2,5]	{"id":5,"path":[2,5]}
6	[2,6]	{"id":6,"path":[2,6]}
7	[3,7]	{"id":7,"path":[3,7]}
8	[3,8]	{"id":8,"path":[3,8]}
9	[2,4,9]	{"id":9,"path":[2,4,9]}


-- !query 76
DROP VIEW tree
-- !query 76 schema
struct<>
-- !query 76 output



-- !query 77
CREATE TEMPORARY VIEW graph AS SELECT * FROM VALUES
  (1, 2, 'arc 1 -> 2'),
  (1, 3, 'arc 1 -> 3'),
  (2, 3, 'arc 2 -> 3'),
  (1, 4, 'arc 1 -> 4'),
  (4, 5, 'arc 4 -> 5'),
  (5, 1, 'arc 5 -> 1')
AS (f, t, label)
-- !query 77 schema
struct<>
-- !query 77 output



-- !query 78
WITH RECURSIVE search_graph AS (
  SELECT *, ARRAY(STRUCT(g.f, g.t)) AS path, false AS cycle FROM graph g
  UNION ALL
  SELECT g.*, path || ARRAY(STRUCT(g.f, g.t)), ARRAY_CONTAINS(path, STRUCT(g.f, g.t))
  FROM graph g, search_graph sg
  WHERE g.f = sg.t AND NOT cycle
)
SELECT * FROM search_graph
-- !query 78 schema
struct<f:int,t:int,label:string,path:array<struct<f:int,t:int>>,cycle:boolean>
-- !query 78 output
1	2	arc 1 -> 2	[{"f":1,"t":2}]	false
1	2	arc 1 -> 2	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
1	2	arc 1 -> 2	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
1	2	arc 1 -> 2	[{"f":5,"t":1},{"f":1,"t":2}]	false
1	3	arc 1 -> 3	[{"f":1,"t":3}]	false
1	3	arc 1 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	3	arc 1 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	3	arc 1 -> 3	[{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	true
1	4	arc 1 -> 4	[{"f":1,"t":4}]	false
1	4	arc 1 -> 4	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	false
1	4	arc 1 -> 4	[{"f":5,"t":1},{"f":1,"t":4}]	false
2	3	arc 2 -> 3	[{"f":1,"t":2},{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
4	5	arc 4 -> 5	[{"f":1,"t":4},{"f":4,"t":5}]	false
4	5	arc 4 -> 5	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	true
4	5	arc 4 -> 5	[{"f":4,"t":5}]	false
4	5	arc 4 -> 5	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	false
5	1	arc 5 -> 1	[{"f":4,"t":5},{"f":5,"t":1}]	false
5	1	arc 5 -> 1	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	true
5	1	arc 5 -> 1	[{"f":5,"t":1}]	false


-- !query 79
WITH RECURSIVE search_graph AS (
  SELECT *, ARRAY(STRUCT(g.f, g.t)) AS path, false AS cycle FROM graph g
  UNION ALL
  SELECT g.*, path || ARRAY(STRUCT(g.f, g.t)), ARRAY_CONTAINS(path, STRUCT(g.f, g.t))
  FROM graph g, search_graph sg
  WHERE g.f = sg.t AND NOT cycle
)
SELECT * FROM search_graph ORDER BY path
-- !query 79 schema
struct<f:int,t:int,label:string,path:array<struct<f:int,t:int>>,cycle:boolean>
-- !query 79 output
1	2	arc 1 -> 2	[{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":1,"t":4}]	false
4	5	arc 4 -> 5	[{"f":1,"t":4},{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	false
1	2	arc 1 -> 2	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	true
2	3	arc 2 -> 3	[{"f":2,"t":3}]	false
4	5	arc 4 -> 5	[{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":4,"t":5},{"f":5,"t":1}]	false
1	2	arc 1 -> 2	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	false
4	5	arc 4 -> 5	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	true
5	1	arc 5 -> 1	[{"f":5,"t":1}]	false
1	2	arc 1 -> 2	[{"f":5,"t":1},{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":5,"t":1},{"f":1,"t":4}]	false
4	5	arc 4 -> 5	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	true


-- !query 80
DROP VIEW graph
-- !query 80 schema
struct<>
-- !query 80 output



-- !query 81
CREATE TEMPORARY VIEW routes AS SELECT * FROM VALUES
  ('New York', 'Washington'),
  ('New York', 'Boston'),
  ('Boston', 'New York'),
  ('Washington', 'Boston'),
  ('Washington', 'Raleigh')
  AS routes(origin, destination)
-- !query 81 schema
struct<>
-- !query 81 output



-- !query 82
WITH RECURSIVE destinations_from_new_york AS (
  SELECT 'New York' AS destination, ARRAY('New York') AS path, 0 AS length
  UNION ALL
  SELECT r.destination, CONCAT(d.path, ARRAY(r.destination)), d.length + 1
  FROM routes AS r
  JOIN destinations_from_new_york AS d ON d.destination = r.origin AND NOT ARRAY_CONTAINS(d.path, r.destination)
)
SELECT * FROM destinations_from_new_york
-- !query 82 schema
struct<destination:string,path:array<string>,length:int>
-- !query 82 output
Boston	["New York","Boston"]	1
Boston	["New York","Washington","Boston"]	2
New York	["New York"]	0
Raleigh	["New York","Washington","Raleigh"]	2
Washington	["New York","Washington"]	1


-- !query 83
DROP VIEW routes
-- !query 83 schema
struct<>
-- !query 83 output



-- !query 84
WITH RECURSIVE fibonacci AS (
  VALUES (0, 1) AS t(a, b)
  UNION ALL
  SELECT b, a + b FROM fibonacci WHERE a < 10
)
SELECT a FROM fibonacci ORDER BY a
-- !query 84 schema
struct<a:int>
-- !query 84 output
0
1
1
2
3
5
8
13


-- !query 85
WITH RECURSIVE sudoku AS (
  VALUES (
    ARRAY(
      0, 0, 6, 0, 2, 3, 0, 0, 1,
      5, 0, 0, 0, 0, 0, 9, 0, 0,
      0, 0, 2, 0, 0, 4, 0, 0, 0,
      2, 0, 0, 8, 0, 0, 0, 9, 3,
      0, 0, 1, 0, 0, 7, 0, 0, 0,
      8, 3, 0, 0, 0, 0, 4, 0, 0,
      6, 0, 0, 1, 0, 0, 5, 0, 4,
      0, 5, 0, 0, 0, 0, 6, 0, 0,
      0, 0, 9, 0, 7, 0, 0, 2, 0
    ),
    0
  ) AS t(puzzle, level)
  UNION ALL
  SELECT
    CONCAT(SLICE(puzzle, 1, newPosition - 1), ARRAY(newValue), SLICE(puzzle, newPosition + 1, 9 * 9 - newPosition)),
    level + 1
  FROM (
    SELECT
      puzzle,
      newPosition,
      EXPLODE(allowedValues) AS newValue,
      level
    FROM (
      SELECT
        puzzle,
        newPosition,
        ARRAY_EXCEPT(
          ARRAY_EXCEPT(
            ARRAY_EXCEPT(
              SEQUENCE(1, 9),
              -- used values in row
              SLICE(puzzle, FLOOR((newPosition - 1) / 9) * 9 + 1, 9)
            ),
            -- used values in column
            TRANSFORM(puzzle, (x, i) -> IF(i % 9 = (newPosition - 1) % 9, x, 0))
          ),
          -- used values in 3x3 block
          TRANSFORM(
            SLICE(puzzle, FLOOR((newPosition - 1) / (3 * 9)) * 3 * 9 + 1, 3 * 9),
            (x, i) -> IF(FLOOR(i / 3) % 3 = FLOOR((newPosition - 1) / 3) % 3, x, 0)
          )
        ) AS allowedValues,
        level
      FROM sudoku
      JOIN (SELECT EXPLODE(SEQUENCE(1, 9 * 9)) AS newPosition) ON puzzle[newPosition - 1] = 0
      ORDER BY SIZE(allowedValues)
      LIMIT 1
    )
  )
)
SELECT * FROM sudoku WHERE NOT ARRAY_CONTAINS(puzzle, 0)
-- !query 85 schema
struct<puzzle:array<int>,level:int>
-- !query 85 output
[4,8,6,9,2,3,7,5,1,5,1,3,7,6,8,9,4,2,7,9,2,5,1,4,8,3,6,2,7,4,8,5,6,1,9,3,9,6,1,3,4,7,2,8,5,8,3,5,2,9,1,4,6,7,6,2,8,1,3,9,5,7,4,3,5,7,4,8,2,6,1,9,1,4,9,6,7,5,3,2,8]	55
